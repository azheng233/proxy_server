#include "msg_policy.h"
#include "chunk.h"
#include "message.h"
#include "url_policy.h"
#include "policy_cache.h"
#include "log.h"
#include "msg_audit.h"
#include "conn_policy.h"
#include "hexstr.h"
#include "conn_peer.h"
#include "ipt_redirect.h"
#include <string.h>

static int plcy_parse_daytime(struct url_policy *purl, uint8_t *data, int len)
{
    uint8_t *p;
    int ret;
    struct time_slice *ptime;
    struct daytime *pday;
    uint8_t slice_len;
    uint8_t *pslice;

    p = data; ptime = NULL; pday = NULL;
    while (p < data + len)
    {
        slice_len = *p++;
        if (p + slice_len > data + len) {
            break;
        }
        pslice = p;

        // daytime
        pday = daytime_new();
        if (!pday) {
            log_error("alloc new daytime dailed");
            break;
        }
        pday->weekday = *p++;
        log_debug("weekday %hhu", pday->weekday);

        // slice
        while (p < pslice + slice_len)
        {
            ptime = time_slice_new();
            if (!ptime) {
                log_error("alloc new time slice failed");
                break;
            }

            ptime->begin_hour = *p++;
            ptime->begin_minute = *p++;
            ptime->end_hour = *p++;
            ptime->end_minute = *p++;
            ret = time_slice_append(pday, ptime);
            if (ret) {
                log_warn("append time slice to daytime failed");
                break;
            }
            log_debug("time slice from %02hhu:%02hhu to %02hhu:%02hhu", ptime->begin_hour, \
                ptime->begin_minute, ptime->end_hour, ptime->end_minute);
            ptime = NULL;
        }
        if (ptime) {
            time_slice_del(ptime);
        }

        ret = daytime_append(purl, pday);
        if (ret) {
            log_warn("append daytime to url policy failed");
            break;
        }
        pday = NULL;
    }

    if (pday) {
        daytime_del(pday);
    }

    return MSG_OK;
}

void close_all_conns_same_ipport(uint32_t ipport, char *snstr)
{
    uint8_t *addr;
    connection_t *c;
    queue_t *q;
    int r;

    addr = (uint8_t *)&(ipport);

    q = connhead.queue.next;
    while (q != &(connhead.queue)) {
        c = queue_data(q, connection_t, queue);

        if (0 == addr[0] && 0 == addr[1]) {
            r = (*(uint16_t*)addr == ((struct sockaddr_in*)c->addr)->sin_port) ? 1 : 0;
        } else {
            r = (*(uint32_t*)addr == ((struct sockaddr_in*)c->addr)->sin_addr.s_addr) ? 1 : 0;
        }

        if (r) {
            conn_signal_thisclose(c);
            log_debug("close connection fd: %d, sn: %s", c->fd, snstr);
        }

        q = q->next;
    }
}

static void close_all_conns_forbidden(struct policy_node *pnode)
{
    struct conninfo *conn;

    conn = pnode->conns;
    while (conn) {
        close_all_conns_same_ipport(conn->ipport, pnode->snstr);
        conn = conn->next;
    }
}

static int plcy_parse_plcy(connection_t *c, uint8_t *sn, uint8_t snlen, uint8_t *data, size_t len)
{
    uint8_t *p;
    int ret;
    uint32_t update_time;
    uint8_t action;
    uint16_t plcylen;
    struct user_policy *usrpcy;
    uint8_t *daytime;
    uint16_t daytime_len;
    char *url;
    uint16_t urlen;
    struct url_policy *urlpcy;
    uint16_t user_info_len;
    uint8_t *user_info;
    int i;

    char snstr[SN_MAX_LEN * 2 + 1];
    int slen = SN_MAX_LEN * 2;
    struct policy_node *pnode;

    hex2str(sn, snlen, snstr, slen);

    p = data;
    if (len < 4 + 2) {
        log_warn("policy length less then time and len field, len: %u, sn: %s", len, snstr);
        return MSG_ERR;
    }

    update_time = ntohl(*(uint32_t*)p);
    p += 4;
    user_info_len = ntohs(*(uint16_t*)p);
    p += 2;
    if (p + user_info_len > data + len) {
        log_error("policy user info len: %u big then total len: %u, sn: %s", user_info_len, len, snstr);
        return MSG_ERR;
    }

    user_info = p;
    p += user_info_len;
    action = *p++;

    pnode = policy_node_find_from_hash_bysn(sn, snlen);
    if (!pnode) {
        pnode = policy_node_create(sn, snlen);
        if (!pnode) {
            log_error("policy node create failed, sn: %s", snstr);
            return MSG_ALT;
        }

        ret = policy_node_insert_to_hash(pnode);
        if (ret) {
            log_error("insert policy node to hash table failed, sn: %s", snstr);
            return MSG_ALT;
        }
    }
    memcpy(pnode->userinfo, user_info, user_info_len);
    pnode->userinfo[user_info_len] = '\0';

    //1.3 action: 0 forbidden, 1 allow
    //1.4 action: 0 forbidden, 1 whitelist policy, 2 blacklist policy
    pnode->isforbidden = (action == 0) ? 1 : 0;

    usrpcy = user_policy_new();
    if (!usrpcy) {
        log_error("malloc for struct user_policy failed, sn: %s", snstr);
        return MSG_ALT;
    }

    usrpcy->type = PLCY_WHITELIST;
    if ((c->version[0] == 0x01) && (c->version[1] = 0x04)) {
        usrpcy->type = (action == 2) ? PLCY_BLACKLIST : PLCY_WHITELIST;
    }

    usrpcy->update_time = update_time;

    while (p < data + len)
    {
        if (p + sizeof(uint16_t) > data + len) {
            break;
        }

        plcylen = ntohs(*(uint16_t*)p);
        p += sizeof(uint16_t);
        if (p + plcylen > data + len) {
            break;
        }

        // daytime
        daytime_len = ntohs(*(uint16_t*)p);
        p += sizeof(uint16_t);
        if (daytime_len > plcylen) {
            break;
        }
        daytime = p;
        p += daytime_len;

        // url
        urlen = ntohs(*(uint16_t*)p);
        p += sizeof(uint16_t);
        if (p + urlen > data + len) {
            break;
        }
        url = (char*)p;
        p += urlen;

        // add
        urlpcy = url_policy_new(urlen);
        if (!urlpcy) {
            log_error("malloc for struct url_policy failed, sn: %s", snstr);
            break;
        }
        for (i = 0; i < urlen; i++) {
            urlpcy->url[i] = url[i];
            if (url[i] >= 'A' || url[i] <= 'Z') {
                urlpcy->url[i] |= 0x20;
            }
        }
        urlpcy->url[i] = '\0';
        urlpcy->url_len = strlen(urlpcy->url);

        ret = plcy_parse_daytime(urlpcy, daytime, daytime_len);
        if (ret) {
            log_error("policy parse daytime failed, sn: %s", snstr);
            break;
        }

        ret = url_policy_append(usrpcy, urlpcy);
        if (ret) {
            log_warn("append url policy to user failed, sn: %s", snstr);
            break;
        }

        log_info("%s policy, url: %s, user info: %s, sn: %s, forbidden: %s",
            ((usrpcy->type == PLCY_WHITELIST) ? "whitelist" : "blacklist"),
            urlpcy->url, pnode->userinfo, snstr, (pnode->isforbidden ? "true" : "false"));

        if (conf[TRANSPARENT_ENABLE].value.num) {
            ret = ipt_redirect_add_url(url, urlen);
            if (ret != 0) {
                log_warn("iptables redirect failed");
            }
        }

        urlpcy = NULL;
    }

    if (urlpcy) {
        url_policy_del(urlpcy);
    }

    if (usrpcy->type == PLCY_WHITELIST) {
        if (!pnode->whitelist) {
            log_info("new user whitelist policy, sn: %s", snstr);
            pnode->whitelist = usrpcy;
        } else {
            log_info("update user whitelist policy, sn: %s", snstr);
            ret = user_policy_update(pnode->whitelist, usrpcy);
            if (ret) {
                log_warn("update user blacklist policy to cache failed, sn: %s", snstr);
            }
            user_policy_del(usrpcy);
        }
    }

    if (usrpcy->type == PLCY_BLACKLIST) {
        if (!pnode->blacklist) {
            log_info("new user blacklist policy, sn: %s", snstr);
            pnode->blacklist = usrpcy;
        } else {
            log_info("update user blacklist policy, sn: %s", snstr);
            ret = user_policy_update(pnode->blacklist, usrpcy);
            if (ret) {
                log_warn("update user blacklist policy to cache failed, sn: %s", snstr);
            }
            user_policy_del(usrpcy);
        }
    }

    if (pnode->isforbidden) {
        close_all_conns_forbidden(pnode);
        policy_node_remove_all_conns(pnode);
    }

    return MSG_OK;
}

static int plcy_parse_response( connection_t *c, uint8_t *data, int len )
{
    uint8_t *p = data;
    int ret;
    uint8_t snlen;
    uint8_t *sn;
    uint8_t type;

    if( len < 2 ) return MSG_ERR;
    snlen = *p++;
    if( len < 2+snlen ) return MSG_ERR;
    sn = p;
    p += snlen;
    type = *p++;

    switch( type )
    {
        case REQ_POLICY_RESPONSE:
            ret = plcy_parse_plcy( c, sn, snlen, p, len-(p-data) );
            break;
        default:
            log_warn( "connection %d recv response msg with unknown type %hhu", c->fd, type );
            return MSG_ERR;
    }
    return ret;
}

static int plcy_parse_msg( connection_t *c, int msglen )
{
    chunk_t *ck = c->readbuf;
    buffer_t *buf = buffer_getfirst( ck );
    int ret;
    uint8_t *p;
    uint8_t type;

    ret = chunk_merge_buffer( ck, buf, msglen );
    if( ret != 0 )
    {
        log_debug( "merge msg failed" );
        return MSG_ERR;
    }
    p = buf->data;
    type = *p++;
    if( ! MSG_CHECK_PROTOCOL_VERSION( p ) )
    {
        log_warn( "msg version %hhu.%hhu wrong", p[0], p[1] );
        return MSG_ERR;
    }
    c->version[0] = p[0]; c->version[1] = p[1];
    p += 2;
    //bodylen = ntohl( *(uint32_t*)p );
    p += sizeof( uint32_t );

    switch( type )
    {
        case MSG_REQUEST:
            ret = plcy_parse_response( c, p, msglen-(p-buf->data) );
            break;
        default:
            log_warn( "connection %d recv unknown msg type %hhu", c->fd, type );
            return MSG_ERR;
    }
    return ret;
}


static size_t msg_get_bodylen( uint8_t *head )
{
#define MSG_LEN_OFFSET  3
#define MSG_LEN_SIZE  sizeof(uint32_t)
    uint8_t *lp = head + MSG_LEN_OFFSET;
    size_t len = 0;

    switch( MSG_LEN_SIZE )
    {
        case 1:
            len = *lp;
            break;
        case 2:
            len = ntohs( *(uint16_t*)lp );
            break;
        case 4:
            len = ntohl( *(uint32_t*)lp );
            break;
        default:
            log_warn( "now not support msg len of length %u", MSG_LEN_SIZE );
            break;
    }
    return len;
}

int policy_parse_data( connection_t *c )
{
    if( NULL==c || NULL==c->readbuf )
        return MSG_ERR;

    chunk_t *ck = c->readbuf;
    buffer_t *buf = NULL;
    int ret;
    int bodylen;
    int msglen;
    int len;
    
    while( ! chunk_isempty( ck ) )
    {
        buf = buffer_getfirst( ck );
        if( NULL == buf )
        {
            log_debug( "connection %d readbuf empty", c->fd );
            goto errmor;
        }

        // head
        ret = chunk_merge_buffer( ck, buf, MSG_HEAD_SIZE );
        if( ret != 0 )
        {
            log_debug( "handle msg head failed, return %d, fd %d", ret, c->fd );
            if( -1 == ret )
                goto errmor;
            goto err;
        }
        bodylen = msg_get_bodylen( buf->data );
        if( bodylen <= 0 || MSG_HEAD_SIZE+bodylen > ck->limit )
        {
            log_warn( "msg length %d wrong, limit %u, fd %d", bodylen+MSG_HEAD_SIZE, ck->limit, c->fd );
            goto err;
        }
        // body
        msglen = MSG_HEAD_SIZE + bodylen;
        len = 0;
        do {
            len += buf->used;
            if( len >= msglen )
                break;
            buf = buffer_getnext( ck, buf );
        } while( NULL != buf );
        if( len < msglen )
            goto errmor;
        // parse
        ret = plcy_parse_msg( c, msglen );
        if( ret == MSG_ERR )
        {
            log_debug( "policy parse msg return %d", ret );
            goto err;
        }
        ret = chunk_erase( ck, msglen );
        log_trace( "erase %d data from connection %d's readbuf, buffer left%sempty", msglen, c->fd, ret?" not ":" " );
    }
errmor:
    return CONN_OK;
err:
    return CONN_ERR;
}

#ifdef WITH_POLICY_TEST
//uint8_t plcy_data[] = {
//    0x0E,
//    0x01,0x03,
//    0x00,0x00,0x00,0xA5,
//    0x08,
//    0x0B,0x10,0x20,0x30,0x40,0x50,0x60,0x70,
//    0x0C,
//    0x12,0x34,0x56,0x78,
//    0x00,0x04,
//    0x31,0x32,0x33,0x34,
//    0x01,
//    0x00,0x44,
//    0x00,0x2A,
//    0x05,0x01,0x00,0x00,0x18,0x00,0x05,0x02,0x00,0x00,0x18,0x00,0x05,0x03,0x00,0x00,
//    0x18,0x00,0x05,0x04,0x00,0x00,0x18,0x00,0x05,0x05,0x00,0x00,0x18,0x00,0x05,0x06,
//    0x00,0x00,0x18,0x00,0x05,0x07,0x00,0x00,0x18,0x00,
//    0x00,0x16,
//    0x68,0x74,0x74,0x70,0x73,0x3A,0x2F,0x2F,0x31,0x39,0x32,0x2E,0x31,0x36,0x38,0x2E,
//    0x33,0x35,0x2E,0x32,0x38,0x2F,
//    0x00,0x48,
//    0x00,0x2A,
//    0x05,0x01,0x00,0x00,0x18,0x00,0x05,0x02,0x00,0x00,0x18,0x00,0x05,0x03,0x00,0x00,
//    0x18,0x00,0x05,0x04,0x00,0x00,0x18,0x00,0x05,0x05,0x00,0x00,0x18,0x00,0x05,0x06,
//    0x00,0x00,0x18,0x00,0x05,0x07,0x00,0x00,0x18,0x00,
//    0x00,0x1A,
//    0x68,0x74,0x74,0x70,0x3A,0x2F,0x2F,0x31,0x39,0x32,0x2E,0x31,0x36,0x38,0x2E,0x33,
//    0x35,0x2E,0x32,0x38,0x3A,0x38,0x30,0x38,0x30,0x2F
//};
uint8_t plcy_data[] = {
    0x0E,
    0x01,0x03,
    0x00,0x00,0x04,0x33,
    0x08,
    0x0B,0x10,0x20,0x30,0x40,0x50,0x60,0x70,
    0x0C,
    0x12,0x34,0x56,0x78,
    0x00,0x04,
    0x31,0x32,0x33,0x34,
    0x01,
    0x00,0x44,
    0x00,0x2A,
    0x05,0x01,0x00,0x00,0x18,0x00,0x05,0x02,0x00,0x00,0x18,0x00,0x05,0x03,0x00,0x00,
    0x18,0x00,0x05,0x04,0x00,0x00,0x18,0x00,0x05,0x05,0x00,0x00,0x18,0x00,0x05,0x06,
    0x00,0x00,0x18,0x00,0x05,0x07,0x00,0x00,0x18,0x00,
    0x00,0x16,
    0x68,0x74,0x74,0x70,0x73,0x3A,0x2F,0x2F,0x31,0x39,0x32,0x2E,0x31,0x36,0x38,0x2E,
    0x33,0x35,0x2E,0x32,0x38,0x2F,
    0x00,0x44,
    0x00,0x2A,
    0x05,0x01,0x00,0x00,0x18,0x00,0x05,0x02,0x00,0x00,0x18,0x00,0x05,0x03,0x00,0x00,
    0x18,0x00,0x05,0x04,0x00,0x00,0x18,0x00,0x05,0x05,0x00,0x00,0x18,0x00,0x05,0x06,
    0x00,0x00,0x18,0x00,0x05,0x07,0x00,0x00,0x18,0x00,
    0x00,0x16,
    0x68,0x74,0x74,0x70,0x73,0x3A,0x2F,0x2F,0x31,0x39,0x32,0x2E,0x31,0x36,0x38,0x2E,
    0x33,0x35,0x2E,0x32,0x39,0x2F,
    0x00,0x44,
    0x00,0x2A,
    0x05,0x01,0x00,0x00,0x18,0x00,0x05,0x02,0x00,0x00,0x18,0x00,0x05,0x03,0x00,0x00,
    0x18,0x00,0x05,0x04,0x00,0x00,0x18,0x00,0x05,0x05,0x00,0x00,0x18,0x00,0x05,0x06,
    0x00,0x00,0x18,0x00,0x05,0x07,0x00,0x00,0x18,0x00,
    0x00,0x16,
    0x68,0x74,0x74,0x70,0x73,0x3A,0x2F,0x2F,0x31,0x39,0x32,0x2E,0x31,0x36,0x38,0x2E,
    0x33,0x35,0x2E,0x33,0x30,0x2F,
    0x00,0x44,
    0x00,0x2A,
    0x05,0x01,0x00,0x00,0x18,0x00,0x05,0x02,0x00,0x00,0x18,0x00,0x05,0x03,0x00,0x00,
    0x18,0x00,0x05,0x04,0x00,0x00,0x18,0x00,0x05,0x05,0x00,0x00,0x18,0x00,0x05,0x06,
    0x00,0x00,0x18,0x00,0x05,0x07,0x00,0x00,0x18,0x00,
    0x00,0x16,
    0x68,0x74,0x74,0x70,0x73,0x3A,0x2F,0x2F,0x31,0x39,0x32,0x2E,0x31,0x36,0x38,0x2E,
    0x33,0x35,0x2E,0x33,0x31,0x2F,
    0x00,0x44,
    0x00,0x2A,
    0x05,0x01,0x00,0x00,0x18,0x00,0x05,0x02,0x00,0x00,0x18,0x00,0x05,0x03,0x00,0x00,
    0x18,0x00,0x05,0x04,0x00,0x00,0x18,0x00,0x05,0x05,0x00,0x00,0x18,0x00,0x05,0x06,
    0x00,0x00,0x18,0x00,0x05,0x07,0x00,0x00,0x18,0x00,
    0x00,0x16,
    0x68,0x74,0x74,0x70,0x73,0x3A,0x2F,0x2F,0x31,0x39,0x32,0x2E,0x31,0x36,0x38,0x2E,
    0x33,0x35,0x2E,0x33,0x32,0x2F,
    0x00,0x44,
    0x00,0x2A,
    0x05,0x01,0x00,0x00,0x18,0x00,0x05,0x02,0x00,0x00,0x18,0x00,0x05,0x03,0x00,0x00,
    0x18,0x00,0x05,0x04,0x00,0x00,0x18,0x00,0x05,0x05,0x00,0x00,0x18,0x00,0x05,0x06,
    0x00,0x00,0x18,0x00,0x05,0x07,0x00,0x00,0x18,0x00,
    0x00,0x16,
    0x68,0x74,0x74,0x70,0x73,0x3A,0x2F,0x2F,0x31,0x39,0x32,0x2E,0x31,0x36,0x38,0x2E,
    0x33,0x35,0x2E,0x33,0x33,0x2F,
    0x00,0x44,
    0x00,0x2A,
    0x05,0x01,0x00,0x00,0x18,0x00,0x05,0x02,0x00,0x00,0x18,0x00,0x05,0x03,0x00,0x00,
    0x18,0x00,0x05,0x04,0x00,0x00,0x18,0x00,0x05,0x05,0x00,0x00,0x18,0x00,0x05,0x06,
    0x00,0x00,0x18,0x00,0x05,0x07,0x00,0x00,0x18,0x00,
    0x00,0x16,
    0x68,0x74,0x74,0x70,0x73,0x3A,0x2F,0x2F,0x31,0x39,0x32,0x2E,0x31,0x36,0x38,0x2E,
    0x33,0x35,0x2E,0x33,0x34,0x2F,
    0x00,0x44,
    0x00,0x2A,
    0x05,0x01,0x00,0x00,0x18,0x00,0x05,0x02,0x00,0x00,0x18,0x00,0x05,0x03,0x00,0x00,
    0x18,0x00,0x05,0x04,0x00,0x00,0x18,0x00,0x05,0x05,0x00,0x00,0x18,0x00,0x05,0x06,
    0x00,0x00,0x18,0x00,0x05,0x07,0x00,0x00,0x18,0x00,
    0x00,0x16,
    0x68,0x74,0x74,0x70,0x73,0x3A,0x2F,0x2F,0x31,0x39,0x32,0x2E,0x31,0x36,0x38,0x2E,
    0x33,0x35,0x2E,0x33,0x35,0x2F,
    0x00,0x44,
    0x00,0x2A,
    0x05,0x01,0x00,0x00,0x18,0x00,0x05,0x02,0x00,0x00,0x18,0x00,0x05,0x03,0x00,0x00,
    0x18,0x00,0x05,0x04,0x00,0x00,0x18,0x00,0x05,0x05,0x00,0x00,0x18,0x00,0x05,0x06,
    0x00,0x00,0x18,0x00,0x05,0x07,0x00,0x00,0x18,0x00,
    0x00,0x16,
    0x68,0x74,0x74,0x70,0x73,0x3A,0x2F,0x2F,0x31,0x39,0x32,0x2E,0x31,0x36,0x38,0x2E,
    0x33,0x35,0x2E,0x33,0x36,0x2F,
    0x00,0x44,
    0x00,0x2A,
    0x05,0x01,0x00,0x00,0x18,0x00,0x05,0x02,0x00,0x00,0x18,0x00,0x05,0x03,0x00,0x00,
    0x18,0x00,0x05,0x04,0x00,0x00,0x18,0x00,0x05,0x05,0x00,0x00,0x18,0x00,0x05,0x06,
    0x00,0x00,0x18,0x00,0x05,0x07,0x00,0x00,0x18,0x00,
    0x00,0x16,
    0x68,0x74,0x74,0x70,0x73,0x3A,0x2F,0x2F,0x31,0x39,0x32,0x2E,0x31,0x36,0x38,0x2E,
    0x33,0x35,0x2E,0x33,0x37,0x2F,
    0x00,0x44,
    0x00,0x2A,
    0x05,0x01,0x00,0x00,0x18,0x00,0x05,0x02,0x00,0x00,0x18,0x00,0x05,0x03,0x00,0x00,
    0x18,0x00,0x05,0x04,0x00,0x00,0x18,0x00,0x05,0x05,0x00,0x00,0x18,0x00,0x05,0x06,
    0x00,0x00,0x18,0x00,0x05,0x07,0x00,0x00,0x18,0x00,
    0x00,0x16,
    0x68,0x74,0x74,0x70,0x73,0x3A,0x2F,0x2F,0x31,0x39,0x32,0x2E,0x31,0x36,0x38,0x2E,
    0x33,0x35,0x2E,0x33,0x38,0x2F,
    0x00,0x44,
    0x00,0x2A,
    0x05,0x01,0x00,0x00,0x18,0x00,0x05,0x02,0x00,0x00,0x18,0x00,0x05,0x03,0x00,0x00,
    0x18,0x00,0x05,0x04,0x00,0x00,0x18,0x00,0x05,0x05,0x00,0x00,0x18,0x00,0x05,0x06,
    0x00,0x00,0x18,0x00,0x05,0x07,0x00,0x00,0x18,0x00,
    0x00,0x16,
    0x68,0x74,0x74,0x70,0x73,0x3A,0x2F,0x2F,0x31,0x39,0x32,0x2E,0x31,0x36,0x38,0x2E,
    0x33,0x35,0x2E,0x33,0x39,0x2F,
    0x00,0x44,
    0x00,0x2A,
    0x05,0x01,0x00,0x00,0x18,0x00,0x05,0x02,0x00,0x00,0x18,0x00,0x05,0x03,0x00,0x00,
    0x18,0x00,0x05,0x04,0x00,0x00,0x18,0x00,0x05,0x05,0x00,0x00,0x18,0x00,0x05,0x06,
    0x00,0x00,0x18,0x00,0x05,0x07,0x00,0x00,0x18,0x00,
    0x00,0x16,
    0x68,0x74,0x74,0x70,0x73,0x3A,0x2F,0x2F,0x31,0x39,0x32,0x2E,0x31,0x36,0x38,0x2E,
    0x33,0x35,0x2E,0x34,0x30,0x2F,
    0x00,0x44,
    0x00,0x2A,
    0x05,0x01,0x00,0x00,0x18,0x00,0x05,0x02,0x00,0x00,0x18,0x00,0x05,0x03,0x00,0x00,
    0x18,0x00,0x05,0x04,0x00,0x00,0x18,0x00,0x05,0x05,0x00,0x00,0x18,0x00,0x05,0x06,
    0x00,0x00,0x18,0x00,0x05,0x07,0x00,0x00,0x18,0x00,
    0x00,0x16,
    0x68,0x74,0x74,0x70,0x73,0x3A,0x2F,0x2F,0x31,0x39,0x32,0x2E,0x31,0x36,0x38,0x2E,
    0x33,0x35,0x2E,0x34,0x31,0x2F,
    0x00,0x48,
    0x00,0x2A,
    0x05,0x01,0x00,0x00,0x18,0x00,0x05,0x02,0x00,0x00,0x18,0x00,0x05,0x03,0x00,0x00,
    0x18,0x00,0x05,0x04,0x00,0x00,0x18,0x00,0x05,0x05,0x00,0x00,0x18,0x00,0x05,0x06,
    0x00,0x00,0x18,0x00,0x05,0x07,0x00,0x00,0x18,0x00,
    0x00,0x1A,
    0x68,0x74,0x74,0x70,0x3A,0x2F,0x2F,0x31,0x39,0x32,0x2E,0x31,0x36,0x38,0x2E,0x33,
    0x35,0x2E,0x32,0x38,0x3A,0x38,0x30,0x38,0x30,0x2F
};
#endif
/**
 * @brief 发送查询全体策略消息
 * @retval	CONN_ERR 发送错误
 * @retval	CONN_OK	发送成功
 */
int plcy_request_all()
{
    buffer_t *buf = buffer_new( MSG_HEAD_SIZE+1+1+4 );
    if( NULL == buf )
    {
        log_error( "alloc policy request buffer failed" );
        return -1;
    }

    uint8_t *p = buf->data + MSG_HEAD_SIZE;
    *p++ = 0;
    *p++ = REQ_POLICY_ALL;
    *(uint32_t*)p = 0;  //last_time
    p += sizeof(uint32_t);

    buf->used = p - buf->data;
    msg_add_head( buf->data, MSG_REQUEST, buf->used-MSG_HEAD_SIZE );
#ifdef WITH_POLICY_TEST
    plcy_parse_response(plcy_conn, ((uint8_t *)plcy_data)+7, 1075);
#endif

    return policy_send_buffer( buf );
}

/**
 * @brief 发送查询个人策略消息
 * @param[in]	sn	证书sn号
 * @param[in]	snlen	证书sn号长度
 * @retval	CONN_ERR 发送错误
 * @retval	CONN_OK	发送成功
 */
int plcy_request_one(uint8_t *sn, uint8_t snlen)
{
    buffer_t *buf = buffer_new( MSG_HEAD_SIZE+1+snlen+1+4 );
    if( NULL == buf )
    {
        log_error( "alloc policy request buffer failed" );
        return -1;
    }

    uint8_t *p = buf->data + MSG_HEAD_SIZE;
    *p++ = snlen;
    memcpy( p, sn, snlen );
    p += snlen;
    *p++ = REQ_POLICY_ONE;
    *(uint32_t*)p = 0;  //last_time
    p += sizeof(uint32_t);

    buf->used = p - buf->data;
    msg_add_head( buf->data, MSG_REQUEST, buf->used-MSG_HEAD_SIZE );

    return policy_send_buffer( buf );
}

